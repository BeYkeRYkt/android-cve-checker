#!/usr/bin/env python3

import getopt
import os
import subprocess
import sys

from utils import ioutils


"""
Reads the Linux version from the kernel Makefile.

Args:
    kernel_repo The path to the kernel repository

Returns
    Linux version string (e.g. "3.10.9").
"""


def parse_linux_version(kernel_repo):

    kernel_version = ""
    makefile_name = "Makefile"

    version_components = ["VERSION", "PATCHLEVEL", "SUBLEVEL", "EXTRAVERSION"]

    with open(kernel_repo + '/' + makefile_name) as mk:
        for line in mk:
            for component in version_components:
                if component in line:
                    number = ""
                    try:
                        number = line.split('=')[1].strip()
                    except IndexError:
                        pass
                    kernel_version += (number + '.')

                # check if we read everything
                if kernel_version.count('.') == len(version_components):
                    # remove trailing version delimiters ('.')
                    while kernel_version.endswith('.'):
                        kernel_version = kernel_version[:-1]
                    return kernel_version


"""
Print usage information about this program.
"""


def print_usage():

    print("usage: cve_apply.py <OPTIONS> kernel_repo\n")
    print("<OPTIONS>")
    print("\t -h          Print this text\n" +
          "\t -i          Path to the file containing the CVE patch names\n" +
          "\t -b          Base directory path containing the CVE patches\n" +
          "\t -p          Push patches to Gerrit\n")


"""
Print current execution progress to the console.

Args:
    current: The current element index.
    total:   The total number of elements to process.

Returns:
    Nothing
"""

def print_progress(current, total):

    print("[I] Progress: " + str(int(current / total * 100)) + "% ("
          + str(current) + "/" + str(total) + ")", end='\r')


"""
Install the Gerrit commit message hook for the Change-ID.

Args:
    path: The path to the git repository.
    user: The Gerrit user name.

Returns:
    The return call of the scp command
"""


def install_commit_hook(path, user):

    cmd = ("scp -p -P 29418 " + user
           + "@review.lineageos.org:hooks/commit-msg " + path
           + "/.git/hooks/")

    return subprocess.call(cmd.split())


"""
Entrypoint to the Python CVE patcher.
"""


def main():

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hpi:b:",
                                   ["help", "push", "input=", "basedir="])
    except getopt.GetoptError as err:
        # print help information and exit
        print(str(err))
        print_usage()
        sys.exit(2)

    # check for required args
    if len(sys.argv) < 2:
        print("[E] Invalid number of args (required: 2, found: "
              + str(len(sys.argv)) + ")!")
        print_usage()
        sys.exit(2)

    # file containing the CVE patch file names
    input_file = None
    # directory containing the CVE patches
    base_dir = None
    # directory containing the kernel repo to be patched
    kernel_repo = sys.argv[-1]
    # whether we should push to Gerrit code review
    push_to_gerrit = False
    gerrit_user = None

    for o, a in opts:
        if o in ("-h", "--help"):
            print_usage()
            sys.exit()
        elif o in ("-p", "--push"):
            push_to_gerrit = True
        elif o in ("-i", "--input"):
            input_file = a
        elif o in ("-b", "--basedir"):
            base_dir = a
        else:
            print("[E] unhandled option: " + o)
            sys.exit(2)

    if not input_file or not ioutils.file_exists(input_file):
        print("[E] invalid CVE input file: " + str(input_file))
        return

    if not base_dir or not ioutils.dir_exists(base_dir):
        print("[E] invalid patch base directory: " + str(base_dir))
        return

    if not kernel_repo or not ioutils.dir_exists(kernel_repo):
        print("[E] invalid kernel directory: " + kernel_repo)
        return

    if ".git" not in os.listdir(kernel_repo):
        print("[E] kernel directory does not seem to be a git repository")
        return

    # if gerrit push was requested, we need the username
    if push_to_gerrit:
        gerrit_user = input("[I] Enter your gerrit user name: ")
        # install the commit hook
        print("[I] Installing gerrit commit-hook to " + kernel_repo)
        install_commit_hook(kernel_repo, gerrit_user)

    # read the kernel version
    linux_version = parse_linux_version(kernel_repo)
    # we only want VERSION + PATCHLEVEL
    while linux_version.count('.') > 1:
        linux_version = linux_version[:linux_version.rfind('.')]

    # load the version specific patches
    version_specifc_patches_dir = os.path.abspath(os.path.join(base_dir, linux_version))

    # figure out which patches we should apply
    patches = []
    with open(input_file, "r") as fp:
        contents = fp.read().split('\n')
        for patch in contents:
            patches.append(os.path.join(version_specifc_patches_dir, patch))

    # apply the git patches
    for patch in patches:
        # command to apply the patches
        cmd = ["git", "-C", kernel_repo, "am", "--3way", patch]
        rc = subprocess.call(cmd, stdout=subprocess.DEVNULL)
        if rc == 0:
            # make sure the commit message hook is applied (for Gerrit Change-ID)
            cmd = ["git", "-C", kernel_repo, "commit", "--amend", "-C", "HEAD"]
            rc = subprocess.call(cmd, stdout=subprocess.DEVNULL)
        else:
            # whatever went wrong, undo it!
            cmd = ["git", "-C", kernel_repo, "reset", "--hard", "HEAD"]
            rc = subprocess.call(cmd, stdout=subprocess.DEVNULL)
            cmd = ["git", "-C", kernel_repo, "am", "--skip"]
            rc = subprocess.call(cmd, stdout=subprocess.DEVNULL)
            print("[E] Failed to apply: " + patch)


if __name__ == "__main__":
    main()
