#!/usr/bin/env python3

import getopt
import os
import subprocess
import sys

from stats_engine import collect_stats
from utils import ioutils


"""
Builds a list of git patches under a given path.

Args:
    path: The path containing the patchfiles.

Returns:
    A list with absolute paths to the patchfiles.
"""


def load_patches(path):

    patches = []
    patch_suffix = ".patch"

    for node in os.listdir(path):
        if node.endswith(patch_suffix):
            patches.append(os.path.abspath(path) + '/' + node)

    patches.sort()

    return patches


"""
Reads the Linux version from the kernel Makefile.

Args:
    kernel_repo The path to the kernel repository

Returns
    Linux version string (e.g. "3.10.9").
"""


def parse_linux_version(kernel_repo):

    kernel_version = ""
    makefile_name = "Makefile"

    version_components = ["VERSION", "PATCHLEVEL", "SUBLEVEL", "EXTRAVERSION"]

    with open(kernel_repo + '/' + makefile_name) as mk:
        for line in mk:
            for component in version_components:
                if component in line:
                    number = ""
                    try:
                        number = line.split('=')[1].strip()
                    except IndexError:
                        pass
                    kernel_version += (number + '.')

                # check if we read everything
                if kernel_version.count('.') == len(version_components):
                    # remove trailing version delimiters ('.')
                    while kernel_version.endswith('.'):
                        kernel_version = kernel_version[:-1]
                    return kernel_version


"""
Check if a git patch applies either cleanly or in reverse.

Args:
    kernel_repo: The kernel git repository.
    cve_patch:   The CVE git patch to check.

Returns:
    0 - patch applies cleanly
    1 - patch applies in reverse (already applied?)
    2 - patch does not apply
"""


def basic_check(kernel_repo, cve_patch):

    # try to apply the patch in reverse
    cmd = ["git", "-C", kernel_repo, "apply", "--3way", "--check", "--reverse",
           cve_patch]
    ret = subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    # patch applies in reverse
    if ret == 0:
        return 1

    # try to apply the patch normally
    cmd = ["git", "-C", kernel_repo, "apply", "--3way", "--check", cve_patch]
    ret = subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    # patch applies normally
    if ret == 0:
        return ret

    # we ran out of options, probably need the advanced check..
    return 2


"""
Print usage information about this program.
"""


def print_usage():

    print("usage: pycve.py <OPTIONS> kernel_repo")
    print("\noutput:")
    print("\t<AC> The CVE patch applies cleanly.")
    print("\t<AR> The CVE patch applies in reverse.")
    print("\t<!!> The CVE patch does not apply.")


"""
Entrypoint to the Python CVE checker.

The output looks like this:
    <AC> The CVE patch applies cleanly.
    <AR> The CVE patch applies in reverse.
    <!!> The CVE patch does not apply.
"""


def main():

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hi:o:",
                                   ["help", "input=", "output="])
    except getopt.GetoptError as err:
        # print help information and exit
        print(str(err))
        print_usage()
        sys.exit(2)

    # check for required args
    if len(sys.argv) < 2:
        print("[E] Invalid number of args (required: 2, found: "
              + str(len(sys.argv)) + ")!")
        print_usage()
        sys.exit(2)

    # directory containing the CVE patches
    input_dir = None
    # directory containing the kernel repo to be patched
    kernel_repo = sys.argv[-1]
    # the place to store the results
    output_dir = None

    for o, a in opts:
        if o in ("-h", "--help"):
            print_usage()
            sys.exit()
        elif o in ("-i", "--input"):
            input_dir = a
        elif o in ("-o", "--output"):
            output_dir = a
        else:
            print("[E] unhandled option: " + o)
            sys.exit(2)

    # check for required directories
    if output_dir:
        ioutils.check_create(output_dir)

    if not input_dir or not ioutils.dir_exists(input_dir):
        print("[E] invalid CVE input directory: " + str(input_dir))
        return

    if not output_dir:
        print("[E] invalid output directory: " + str(output_dir))
        return

    if not kernel_repo or not ioutils.dir_exists(kernel_repo):
        print("[E] invalid kernel directory: " + kernel_repo)
        return

    if ".git" not in os.listdir(kernel_repo):
        print("[E] kernel directory does not seem to be a git repository")
        return

    # file containing the already applied CVEs
    applied_file = os.path.join(output_dir, "CVE_applied")
    # file containing the conflicting CVEs
    conflicting_file = os.path.join(output_dir, "CVE_conflicts")
    # file containing the clean CVEs
    clean_file = os.path.join(output_dir, "CVE_clean")

    # read the kernel version
    linux_version = parse_linux_version(kernel_repo)
    # we only want VERSION + PATCHLEVEL
    while linux_version.count('.') > 1:
        linux_version = linux_version[:linux_version.rfind('.')]

    # load the version specific patches
    version_specifc_patches_dir = input_dir
    if not input_dir.endswith('/'):
        version_specifc_patches_dir += '/'
    version_specifc_patches_dir += linux_version
    patches = load_patches(version_specifc_patches_dir)

    # open files
    applied_file_fp = open(applied_file, "w")
    clean_file_fp = open(clean_file, "w")
    conflicting_file_fp = open(conflicting_file, "w")

    # perform the actual checking and log to console
    progress = 0
    patch_count = len(patches)
    for cve_patch in patches:
        # print progress
        print("[I] Progress: " + str(int(progress / patch_count * 100))
              + "% (" + str(progress) + "/" + str(patch_count) + ")",
              end='\r')
        progress += 1
 
        res = basic_check(kernel_repo, cve_patch)
        if res == 0:
            clean_file_fp.write(os.path.basename(cve_patch) + "\n")
        elif res == 1:
            applied_file_fp.write(os.path.basename(cve_patch) + "\n")
        elif res == 2:
            conflicting_file_fp.write(os.path.basename(cve_patch) + "\n")

            # print stats
            (added, removed) = collect_stats(kernel_repo, cve_patch)
            stats_string = "\tstats: "
            if added is not None:
                (actual_plus, total_plus) = added
                stats_string += (str(actual_plus) + '/' + str(total_plus)
                                 + " insertions(+)")
            if removed is not None:
                # print a separator if needed
                stats_string += ", "
                (actual_minus, total_minus) = removed
                stats_string += (str(actual_minus) + '/' + str(total_minus)
                      + " deletions(-)")
            conflicting_file_fp.write(stats_string + "\n")

    # close file pointers
    applied_file_fp.close()
    clean_file_fp.close()
    conflicting_file_fp.close()


if __name__ == "__main__":
    main()
