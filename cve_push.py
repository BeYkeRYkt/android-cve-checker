#!/usr/bin/env python3

import collections
import getopt
import os
import subprocess
import sys

from utils import ioutils


"""
Print usage information about this program.
"""


def print_usage():

    print("usage: cve_push.py <OPTIONS> kernel_repo\n")
    print("<OPTIONS>")
    print("\t -h          Print this text\n" +
          "\t -i          Path to the file containing the CVE ID <-> SHA\n" + 
          "\t -u          Your Gerrit user name\n" +
          "\t -b          The destination branch\n")


"""
Print current execution progress to the console.

Args:
    current: The current element index.
    total:   The total number of elements to process.

Returns:
    Nothing
"""

def print_progress(current, total):

    print("[I] Progress: " + str(int(current / total * 100)) + "% ("
          + str(current) + "/" + str(total) + ")", end='\r')


"""
Install the Gerrit commit message hook for the Change-ID.

Args:
    path: The path to the git repository.
    user: The Gerrit user name.

Returns:
    The return call of the scp command
"""


def install_commit_hook(path, user):

    cmd = ("scp -p -P 29418 " + user
           + "@review.lineageos.org:hooks/commit-msg " + path
           + "/.git/hooks/")

    return subprocess.call(cmd.split())


"""
Push the current HEAD to the Gerrit repo.

Args:
    local_path:  The path to the local git repository.
    remote_path: The path to the git repository on the Gerrit server.
    user:        The Gerrit user name.
    branch:      The branch to push to.
    topic:       The topic for the patch (optional).

Returns:
    The return call of the scp command
"""


def push_to_gerrit(local_path, remote_path, user, branch, topic=None):

    cmd = ("git -C " + local_path + " push ssh://" + user
           + "@review.lineageos.org:29418/LineageOS/" + remote_path
           + " HEAD:refs/for/" + branch)
    if topic:
        cmd += ("%topic=" + topic)

    return subprocess.call(cmd.split(), stdout=subprocess.DEVNULL)


"""
Read information about the patches we applied from a file.

Args:
    path: The path to the file containing a key value map of CVE IDs and
          commit SHAs.

Returns:
    The key value map
"""


def read_patch_kvmap(path):

    kvmap = {}

    with open(path, "r") as fp:
        # add existing information to our map
        file_lines = fp.read().strip().split('\n')
        for line in file_lines:
            elems = line.split('\t')
            if len(elems) < 2:
                # TODO: should never happen
                continue
            kvmap[elems[0]] = elems[1]

    return kvmap


"""
Entrypoint for callers

Args:
    kernel_repo: The path to the kernel git repository to patch.
    input_file:  The path to the file telling us which CVE patches to push.
    gerrit_user: Your Gerit user name for ssh push access.
    branch:      The destination branch to push to.

Returns:
    Nothing
"""


def run(kernel_repo, input_file, gerrit_user, branch):

    # install the commit hook
    print("[I] Installing gerrit commit-hook to " + kernel_repo)
    install_commit_hook(kernel_repo, gerrit_user)

    # try to determine the gerrit remote
    git_config_path = os.path.join(kernel_repo, ".git", "config")
    gerrit_remote = None
    try:
        fp = open(git_config_path, "r")
        contents = fp.read().split('\n')
        for line in contents:
            if "url" in line:
                url = line.split()[-1]
                gerrit_remote = os.path.basename(url)
    except IOError:
        print("[E] Failed to open file: " + git_config_path)
    finally:
        fp.close()

    if not gerrit_remote:
        print("[W] Failed to determine gerrit remote, please enter manually")
        print("[W] An example would be: android_kernel_samsung_gts2.git")
        gerrit_remote = input("[W] Remote git repo: ")

    # figure out which patches we should push
    cve_map = read_patch_kvmap(input_file)

    # save the current HEAD SHA
    cmd = ["git", "-C", kernel_repo, "log", "-1", "--pretty=format:%H"]
    current_head = subprocess.check_output(cmd).decode("utf-8")

    progress = 0
    patch_count = len(cve_map)
    for cve_id in cve_map:
        print("[I] Pushing " + cve_id)
        print_progress(progress, patch_count)
        progress += 1
        if progress == patch_count:
            print_progress(progress, patch_count)
            print()

        cve_sha = cve_map[cve_id]
        # checkout the commit for the given CVE id
        cmd = ["git", "-C", kernel_repo, "checkout", cve_sha]
        rc = subprocess.call(cmd, stdout=subprocess.DEVNULL)
        # remove the CVE id suffix starting with an underscore
        # we do this so we can identify multiple git patches belonging to the
        # same CVE and set the topic accordingly
        actual_cve_id = cve_id
        suffix_start = cve_id.rfind('_')
        if suffix_start > 0:
            actual_cve_id = cve_id[0:suffix_start]
        # perform the actual push
        rc = push_to_gerrit(kernel_repo, gerrit_remote, gerrit_user, branch,
                            actual_cve_id)
        if rc != 0:
            print("[E] Failed to push " + cve_id + " to Gerrit")

    # restore the HEAD SHA
    cmd = ["git", "-C", kernel_repo, "checkout", current_head]
    rc = subprocess.call(cmd, stdout=subprocess.DEVNULL)


"""
Entrypoint to the Python CVE pusher.
"""


def main():

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hi:u:b:",
                                   ["help", "input=", "user=", "branch="])
    except getopt.GetoptError as err:
        # print help information and exit
        print(str(err))
        print_usage()
        sys.exit(2)

    # check for required args
    if len(sys.argv) < 2:
        print("[E] Invalid number of args (required: 2, found: "
              + str(len(sys.argv)) + ")!")
        print_usage()
        sys.exit(2)

    # file containing the CVE patch file names
    input_file = None
    # directory containing the kernel repo to be patched
    kernel_repo = sys.argv[-1]
    # Gerrit user
    gerrit_user = None
    # destination git branch
    branch = None

    for o, a in opts:
        if o in ("-h", "--help"):
            print_usage()
            sys.exit()
        elif o in ("-i", "--input"):
            input_file = a
        elif o in ("-u", "--user"):
            gerrit_user = a
        elif o in ("-b", "--branch"):
            branch = a
        else:
            print("[E] unhandled option: " + o)
            sys.exit(2)

    if not input_file or not ioutils.file_exists(input_file):
        print("[E] invalid CVE input file: " + str(input_file))
        return

    if not kernel_repo or not ioutils.dir_exists(kernel_repo):
        print("[E] invalid kernel directory: " + kernel_repo)
        return

    if ".git" not in os.listdir(kernel_repo):
        print("[E] kernel directory does not seem to be a git repository")
        return

    run(kernel_repo, input_file, gerrit_user, branch)


if __name__ == "__main__":
    main()
