From ab17770625ffe74df3b423311fa717225d1a445e Mon Sep 17 00:00:00 2001
From: Katish Paran <kparan@codeaurora.org>
Date: Mon, 11 May 2015 15:33:28 +0530
Subject: diag: dci: Add mutex protection while accessing client details

Currently while extracting events and logs information from
the data read over peripherals, the clients details are accessed
without mutex protection. As the client access may happen from
multiple context, mutex protection is needed. This patch
resolves the same.

Bug: 62378232
Change-Id: I9bd115e1cd9eebc625f4a68854d554ff874d866d
Signed-off-by: Katish Paran <kparan@codeaurora.org>
---
 drivers/char/diag/diag_dci.c      | 23 +++++++++++++++++++----
 drivers/char/diag/diagchar_core.c | 34 +++++++++++++++++++++++++---------
 2 files changed, 44 insertions(+), 13 deletions(-)

diff --git a/drivers/char/diag/diag_dci.c b/drivers/char/diag/diag_dci.c
index 1532928..2fb2c1f 100644
--- a/drivers/char/diag/diag_dci.c
+++ b/drivers/char/diag/diag_dci.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2015, 2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -342,6 +342,7 @@ void diag_dci_wakeup_clients()
 	struct list_head *start, *temp;
 	struct diag_dci_client_tbl *entry = NULL;
 
+	mutex_lock(&driver->dci_mutex);
 	list_for_each_safe(start, temp, &driver->dci_client_list) {
 		entry = list_entry(start, struct diag_dci_client_tbl, track);
 
@@ -357,6 +358,7 @@ void diag_dci_wakeup_clients()
 						     DCI_DATA_TYPE);
 		}
 	}
+	mutex_unlock(&driver->dci_mutex);
 }
 
 void dci_data_drain_work_fn(struct work_struct *work)
@@ -367,6 +369,7 @@ void dci_data_drain_work_fn(struct work_struct *work)
 	struct diag_dci_buf_peripheral_t *proc_buf = NULL;
 	struct diag_dci_buffer_t *buf_temp = NULL;
 
+	mutex_lock(&driver->dci_mutex);
 	list_for_each_safe(start, temp, &driver->dci_client_list) {
 		entry = list_entry(start, struct diag_dci_client_tbl, track);
 		for (i = 0; i < entry->num_buffers; i++) {
@@ -396,6 +399,7 @@ void dci_data_drain_work_fn(struct work_struct *work)
 						     DCI_DATA_TYPE);
 		}
 	}
+	mutex_unlock(&driver->dci_mutex);
 	dci_timer_in_progress = 0;
 }
 
@@ -561,6 +565,8 @@ start:
 		buf += header_len + dci_pkt_len; /* advance to next DCI pkt */
 	}
 end:
+	if (err)
+		return err;
 	/* wake up all sleeping DCI clients which have some data */
 	diag_dci_wakeup_clients();
 	dci_check_drain_timer();
@@ -621,6 +627,8 @@ int diag_process_smd_dci_read_data(struct diag_smd_info *smd_info, void *buf,
 		buf += 5 + dci_pkt_len; /* advance to next DCI pkt */
 	}
 
+	if (err)
+		return err;
 	/* wake up all sleeping DCI clients which have some data */
 	diag_dci_wakeup_clients();
 	dci_check_drain_timer();
@@ -967,9 +975,11 @@ void extract_dci_pkt_rsp(unsigned char *buf, int len, int data_source,
 		return;
 	}
 
+	mutex_lock(&driver->dci_mutex);
 	req_entry = diag_dci_get_request_entry(tag);
 	if (!req_entry) {
-		pr_err("diag: No matching client for DCI data\n");
+		pr_err_ratelimited("diag: No matching client for DCI data\n");
+		mutex_unlock(&driver->dci_mutex);
 		return;
 	}
 
@@ -977,18 +987,17 @@ void extract_dci_pkt_rsp(unsigned char *buf, int len, int data_source,
 	if (!entry) {
 		pr_err("diag: In %s, couldn't find client entry, id:%d\n",
 						__func__, req_entry->client_id);
+		mutex_unlock(&driver->dci_mutex);
 		return;
 	}
 
 	save_req_uid = req_entry->uid;
 	/* Remove the headers and send only the response to this function */
-	mutex_lock(&driver->dci_mutex);
 	delete_flag = diag_dci_remove_req_entry(temp, rsp_len, req_entry);
 	if (delete_flag < 0) {
 		mutex_unlock(&driver->dci_mutex);
 		return;
 	}
-	mutex_unlock(&driver->dci_mutex);
 
 	rsp_buf = entry->buffers[data_source].buf_cmd;
 
@@ -1006,6 +1015,7 @@ void extract_dci_pkt_rsp(unsigned char *buf, int len, int data_source,
 		if (!temp_buf) {
 			pr_err("diag: DCI realloc failed\n");
 			mutex_unlock(&rsp_buf->data_mutex);
+			mutex_unlock(&driver->dci_mutex);
 			return;
 		} else {
 			rsp_buf->data = temp_buf;
@@ -1041,6 +1051,7 @@ void extract_dci_pkt_rsp(unsigned char *buf, int len, int data_source,
 	 * for log and event buffers to be full
 	 */
 	dci_add_buffer_to_list(entry, rsp_buf);
+	mutex_unlock(&driver->dci_mutex);
 }
 
 static void copy_dci_event(unsigned char *buf, int len,
@@ -1176,6 +1187,7 @@ void extract_dci_events(unsigned char *buf, int len, int data_source, int token)
 		   the event data */
 		total_event_len = 2 + 10 + payload_len_field + payload_len;
 		/* parse through event mask tbl of each client and check mask */
+		mutex_lock(&driver->dci_mutex);
 		list_for_each_safe(start, temp, &driver->dci_client_list) {
 			entry = list_entry(start, struct diag_dci_client_tbl,
 									track);
@@ -1187,6 +1199,7 @@ void extract_dci_events(unsigned char *buf, int len, int data_source, int token)
 					       entry, data_source);
 			}
 		}
+		mutex_unlock(&driver->dci_mutex);
 	}
 }
 
@@ -1278,6 +1291,7 @@ void extract_dci_log(unsigned char *buf, int len, int data_source, int token)
 	}
 
 	/* parse through log mask table of each client and check mask */
+	mutex_lock(&driver->dci_mutex);
 	list_for_each_safe(start, temp, &driver->dci_client_list) {
 		entry = list_entry(start, struct diag_dci_client_tbl, track);
 		if (entry->client_info.token != token)
@@ -1289,6 +1303,7 @@ void extract_dci_log(unsigned char *buf, int len, int data_source, int token)
 			copy_dci_log(buf, len, entry, data_source);
 		}
 	}
+	mutex_unlock(&driver->dci_mutex);
 }
 
 void diag_update_smd_dci_work_fn(struct work_struct *work)
diff --git a/drivers/char/diag/diagchar_core.c b/drivers/char/diag/diagchar_core.c
index 2d9f1015..44ec2fe 100644
--- a/drivers/char/diag/diagchar_core.c
+++ b/drivers/char/diag/diagchar_core.c
@@ -1552,7 +1552,10 @@ static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,
 		goto exit;
 	}
 
+exit:
+	mutex_unlock(&driver->diagchar_mutex);
 	if (driver->data_ready[index] & DCI_DATA_TYPE) {
+		mutex_lock(&driver->dci_mutex);
 		/* Copy the type of data being passed */
 		data_type = driver->data_ready[index] & DCI_DATA_TYPE;
 		list_for_each_safe(start, temp, &driver->dci_client_list) {
@@ -1562,16 +1565,28 @@ static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,
 				continue;
 			if (!entry->in_service)
 				continue;
-			COPY_USER_SPACE_OR_EXIT(buf + ret, data_type,
-								sizeof(int));
-			COPY_USER_SPACE_OR_EXIT(buf + ret,
-					entry->client_info.token, sizeof(int));
+			if (copy_to_user(buf + ret, &data_type, sizeof(int))) {
+				mutex_unlock(&driver->dci_mutex);
+				goto end;
+			}
+			ret += sizeof(int);
+			if (copy_to_user(buf + ret, &entry->client_info.token,
+				sizeof(int))) {
+				mutex_unlock(&driver->dci_mutex);
+				goto end;
+			}
+			ret += sizeof(int);
 			copy_dci_data = 1;
 			exit_stat = diag_copy_dci(buf, count, entry, &ret);
+			mutex_lock(&driver->diagchar_mutex);
 			driver->data_ready[index] ^= DCI_DATA_TYPE;
-			if (exit_stat == 1)
-				goto exit;
+			mutex_unlock(&driver->diagchar_mutex);
+			if (exit_stat == 1) {
+				mutex_unlock(&driver->dci_mutex);
+				goto end;
+			}
 		}
+		mutex_lock(&driver->diagchar_mutex);
 		for (i = 0; i < NUM_SMD_DCI_CHANNELS; i++) {
 			if (driver->smd_dci[i].ch) {
 				queue_work(driver->diag_dci_wq,
@@ -1589,10 +1604,11 @@ static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,
 				}
 			}
 		}
-		goto exit;
+		mutex_unlock(&driver->diagchar_mutex);
+		mutex_unlock(&driver->dci_mutex);
+		goto end;
 	}
-exit:
-	mutex_unlock(&driver->diagchar_mutex);
+end:
 	/*
 	 * Flush any read that is currently pending on DCI data and
 	 * command channnels. This will ensure that the next read is not
-- 
cgit v1.1

