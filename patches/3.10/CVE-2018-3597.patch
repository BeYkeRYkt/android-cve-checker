From 71a0cf4c75b116497246e27279afa54365349332 Mon Sep 17 00:00:00 2001
From: Tharun Kumar Merugu <mtharu@codeaurora.org>
Date: Tue, 30 Jan 2018 15:43:36 +0530
Subject: [PATCH] msm: ADSPRPC: Use ID in response to get context pointer

Send context ID in rpc header instead of context pointer.
Validate context ID received in response and get context pointer.

Bug: 74237782
Change-Id: I9cfd10d0c1b25c3085b8e15c7ca1c8ff214bf10d
Acked-by: Viswanatham Paduchuri <vpaduchu@qti.qualcomm.com>
Signed-off-by: Tharun Kumar Merugu <mtharu@codeaurora.org>
Signed-off-by: Steve Pfetsch <spfetsch@google.com>
---
 drivers/char/adsprpc.c        | 73 ++++++++++++++++++++++++++++++++---
 drivers/char/adsprpc_shared.h |  4 +-
 2 files changed, 70 insertions(+), 7 deletions(-)

diff --git a/drivers/char/adsprpc.c b/drivers/char/adsprpc.c
index 9c6e54096b749..865c856716108 100644
--- a/drivers/char/adsprpc.c
+++ b/drivers/char/adsprpc.c
@@ -62,6 +62,9 @@
 				up_read(&current->mm->mmap_sem);\
 		} while (0)
 
+#define FASTRPC_CTX_MAGIC (0xbeeddeed)
+#define FASTRPC_CTX_MAX (256)
+#define FASTRPC_CTXID_MASK (0xFF0)
 
 #define IS_CACHE_ALIGNED(x) (((x) & ((L1_CACHE_BYTES)-1)) == 0)
 
@@ -91,6 +94,13 @@ static inline uint32_t buf_page_size(uint32_t size)
 	return sz > PAGE_SIZE ? sz : PAGE_SIZE;
 }
 
+static inline uint64_t ptr_to_uint64(void *ptr)
+{
+	uint64_t addr = (uint64_t)((uintptr_t)ptr);
+
+	return addr;
+}
+
 static inline int buf_get_pages(void *addr, ssize_t sz, int nr_pages,
 				int access, struct smq_phy_page *pages,
 				int nr_elems, struct smq_phy_page *range)
@@ -178,6 +188,8 @@ struct smq_invoke_ctx {
 	uint32_t sc;
 	struct overlap *overs;
 	struct overlap **overps;
+	unsigned int magic;
+	uint64_t ctxid;
 };
 
 struct smq_context_list {
@@ -216,6 +228,8 @@ struct fastrpc_apps {
 	spinlock_t wrlock;
 	spinlock_t hlock;
 	struct hlist_head htbl[RPC_HASH_SZ];
+	spinlock_t ctxlock;
+	struct smq_invoke_ctx *ctxtable[FASTRPC_CTX_MAX];
 };
 
 struct fastrpc_mmap {
@@ -507,9 +521,10 @@ static int context_alloc(struct fastrpc_apps *me, uint32_t kernel,
 				struct file_data *fdata,
 				struct smq_invoke_ctx **po)
 {
-	int err = 0, bufs, size = 0;
+	int err = 0, bufs, ii, size = 0;
 	struct smq_invoke_ctx *ctx = 0;
 	struct smq_context_list *clst = &me->clst;
+
 	struct fastrpc_ioctl_invoke *invoke = &invokefd->inv;
 
 	bufs = REMOTE_SCALARS_INBUFS(invoke->sc) +
@@ -562,10 +577,26 @@ static int context_alloc(struct fastrpc_apps *me, uint32_t kernel,
 	ctx->pid = current->pid;
 	ctx->tgid = current->tgid;
 	init_completion(&ctx->work);
+	ctx->magic = FASTRPC_CTX_MAGIC;
 	spin_lock(&clst->hlock);
 	hlist_add_head(&ctx->hn, &clst->pending);
 	spin_unlock(&clst->hlock);
 
+	spin_lock(&me->ctxlock);
+	for (ii = 0; ii < FASTRPC_CTX_MAX; ii++) {
+		if (!me->ctxtable[ii]) {
+			me->ctxtable[ii] = ctx;
+			ctx->ctxid = (ptr_to_uint64(ctx) & ~0xFFF)|(ii << 4);
+			break;
+		}
+	}
+	spin_unlock(&me->ctxlock);
+	VERIFY(err, ii < FASTRPC_CTX_MAX);
+	if (err) {
+		pr_err("adsprpc: out of context memory\n");
+		goto bail;
+	}
+
 	*po = ctx;
 bail:
 	if (ctx && err)
@@ -593,6 +624,7 @@ static void context_free(struct smq_invoke_ctx *ctx, int remove)
 	int ssrcount = ctx->fdata->ssrcount;
 	struct fastrpc_smmu *smmu = &apps->channel[cid].smmu;
 	struct fastrpc_buf *b;
+	struct fastrpc_apps *me = &gfa;
 	int i, bufs;
 	if (ctx->smmu) {
 		bufs = REMOTE_SCALARS_INBUFS(ctx->sc) +
@@ -614,6 +646,17 @@ static void context_free(struct smq_invoke_ctx *ctx, int remove)
 		free_mem(b, ctx->fdata);
 
 	kfree(ctx->abufs);
+	ctx->magic = 0;
+	ctx->ctxid = 0;
+
+	spin_lock(&me->ctxlock);
+	for (i = 0; i < FASTRPC_CTX_MAX; i++) {
+		if (me->ctxtable[i] == ctx) {
+			me->ctxtable[i] = NULL;
+			break;
+		}
+	}
+	spin_unlock(&me->ctxlock);
 	if (ctx->dev) {
 		add_dev(apps, ctx->dev);
 		if (ctx->obuf.handle != ctx->dev->buf.handle)
@@ -1092,7 +1135,7 @@ static int fastrpc_invoke_send(struct fastrpc_apps *me,
 	msg.tid = current->pid;
 	if (kernel)
 		msg.pid = 0;
-	msg.invoke.header.ctx = ctx;
+	msg.invoke.header.ctx = ctx->ctxid;
 	msg.invoke.header.handle = handle;
 	msg.invoke.header.sc = sc;
 	msg.invoke.page.addr = buf->phys;
@@ -1122,16 +1165,35 @@ static void fastrpc_deinit(void)
 static void fastrpc_read_handler(int cid)
 {
 	struct fastrpc_apps *me = &gfa;
-	struct smq_invoke_rsp rsp;
-	int ret = 0;
+	struct smq_invoke_rsp rsp = {0};
+	int ret = 0, err = 0;
+	uint32_t index;
 
 	do {
 		ret = smd_read_from_cb(me->channel[cid].chan, &rsp,
 					sizeof(rsp));
 		if (ret != sizeof(rsp))
 			break;
-		context_notify_user(rsp.ctx, rsp.retval);
+		index = (uint32_t)((rsp.ctx & FASTRPC_CTXID_MASK) >> 4);
+		VERIFY(err, index < FASTRPC_CTX_MAX);
+		if (err)
+			goto bail;
+
+		VERIFY(err, !IS_ERR_OR_NULL(me->ctxtable[index]));
+		if (err)
+			goto bail;
+
+		VERIFY(err, ((me->ctxtable[index]->ctxid == (rsp.ctx)) &&
+			me->ctxtable[index]->magic == FASTRPC_CTX_MAGIC));
+		if (err)
+			goto bail;
+
+		context_notify_user(me->ctxtable[index], rsp.retval);
 	} while (ret == sizeof(rsp));
+
+bail:
+	if (err)
+			pr_err("adsprpc: invalid response or context\n");
 }
 
 static void smd_event_handler(void *priv, unsigned event)
@@ -1162,6 +1224,7 @@ static int fastrpc_init(void)
 
 	spin_lock_init(&me->hlock);
 	spin_lock_init(&me->wrlock);
+	spin_lock_init(&me->ctxlock);
 	mutex_init(&me->smd_mutex);
 	context_list_ctor(&me->clst);
 	for (i = 0; i < RPC_HASH_SZ; ++i)
diff --git a/drivers/char/adsprpc_shared.h b/drivers/char/adsprpc_shared.h
index c0f8d3cc8c4e3..c8e31369cef16 100644
--- a/drivers/char/adsprpc_shared.h
+++ b/drivers/char/adsprpc_shared.h
@@ -137,7 +137,7 @@ struct fastrpc_ioctl_mmap {
 };
 
 struct smq_null_invoke {
-	struct smq_invoke_ctx *ctx; /* invoke caller context */
+	uint64_t ctx;		    /* invoke caller context */
 	uint32_t handle;	    /* handle to invoke */
 	uint32_t sc;		    /* scalars structure describing the data */
 };
@@ -164,7 +164,7 @@ struct smq_msg {
 };
 
 struct smq_invoke_rsp {
-	struct smq_invoke_ctx *ctx;  /* invoke caller context */
+	uint64_t ctx;            /* invoke caller context */
 	int retval;	             /* invoke return value */
 };
 
