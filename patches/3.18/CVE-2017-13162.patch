From e4d3cddf13d9073668712758ffc6646168dcaed4 Mon Sep 17 00:00:00 2001
From: Todd Kjos <tkjos@google.com>
Date: Fri, 29 Sep 2017 13:25:33 -0700
Subject: [PATCH] ANDROID: binder: fix OOB write in __binder_update_page_range

commit e12f1f1c65a9 ("binder: always allocate/map first
BINDER_MIN_ALLOC pages") introduced a vulnerability where
the alloc->pages array can be accessed beyond the allocated
elements. For this to occur, the passed-in VMA range must
be < BINDER_MIN_ALLOC pages (which cannot happen for normal
use cases). BINDER_MIN_ALLOC is set to 6 pages, so mmap'ing
1 page results in OOB accesses.

The fix is to return an error if binder_mmap is called with
a VMA size less than BINDER_MIN_ALLOC.

Bug: 64216036
Test: verified fixed with submitter's test program
Change-Id: I4b6dbf3f466fea46e587d6a33f724ee4fe7f1368
Signed-off-by: Todd Kjos <tkjos@google.com>
---
 drivers/staging/android/binder_alloc.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/staging/android/binder_alloc.c b/drivers/staging/android/binder_alloc.c
index e2d392d48db7d..f5be827e3073a 100644
--- a/drivers/staging/android/binder_alloc.c
+++ b/drivers/staging/android/binder_alloc.c
@@ -594,6 +594,11 @@ int binder_alloc_mmap_handler(struct binder_alloc *alloc,
 		}
 	}
 #endif
+	if (vma->vm_end - vma->vm_start < BINDER_MIN_ALLOC) {
+		ret = -EINVAL;
+		failure_string = "VMA size < BINDER_MIN_ALLOC";
+		goto err_vma_too_small;
+	}
 	alloc->pages = kzalloc(sizeof(alloc->pages[0]) *
 				   ((vma->vm_end - vma->vm_start) / PAGE_SIZE),
 			       GFP_KERNEL);
@@ -627,6 +632,7 @@ int binder_alloc_mmap_handler(struct binder_alloc *alloc,
 	kfree(alloc->pages);
 	alloc->pages = NULL;
 err_alloc_pages_failed:
+err_vma_too_small:
 	mutex_lock(&binder_alloc_mmap_lock);
 	vfree(alloc->buffer);
 	alloc->buffer = NULL;
