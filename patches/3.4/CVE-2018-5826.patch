From 8bcc36b2b0d87a4c173cb1a66e8959d6466bc539 Mon Sep 17 00:00:00 2001
From: Ashish Kumar Dhanotiya <adhanoti@codeaurora.org>
Date: Fri, 5 Jan 2018 10:54:04 +0530
Subject: [PATCH] qcacld-3.0: Use after free in hdd_debugfs_stats_update api

Currently there is no locking mechanism to protect global
variable ll_stats.result in hdd_debugfs_stats_update api and
wlan_hdd_llstats_free_buf api so if two threads access the file
simultaneously there is a possibility of use after free of the
llstats buffer.

To address this issue add a mutex to prevent the simultaneous
access of the llstats buffer.

Bug: 69128800
CRs-Fixed: 2157283
Signed-off-by: Ecco Park <eccopark@google.com>
---
 .../core/hdd/src/wlan_hdd_debugfs_llstat.c    | 38 ++++++++++++++++---
 1 file changed, 33 insertions(+), 5 deletions(-)

diff --git a/drivers/staging/qcacld-3.0/core/hdd/src/wlan_hdd_debugfs_llstat.c b/drivers/staging/qcacld-3.0/core/hdd/src/wlan_hdd_debugfs_llstat.c
index 22dd0671183d0..5e44953162d28 100644
--- a/drivers/staging/qcacld-3.0/core/hdd/src/wlan_hdd_debugfs_llstat.c
+++ b/drivers/staging/qcacld-3.0/core/hdd/src/wlan_hdd_debugfs_llstat.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2017 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2018 The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -38,6 +38,8 @@ struct ll_stats_buf {
 
 static struct ll_stats_buf ll_stats;
 
+static DEFINE_MUTEX(llstats_mutex);
+
 void hdd_debugfs_process_iface_stats(hdd_adapter_t *adapter,
 		void *data, uint32_t num_peers)
 {
@@ -51,6 +53,14 @@ void hdd_debugfs_process_iface_stats(hdd_adapter_t *adapter,
 	uint8_t *buffer;
 
 	ENTER();
+
+	mutex_lock(&llstats_mutex);
+	if (!ll_stats.result) {
+		mutex_unlock(&llstats_mutex);
+		hdd_err("LL statistics buffer is NULL");
+		return;
+	}
+
 	iface_stat = data;
 
 	buffer = ll_stats.result;
@@ -59,6 +69,7 @@ void hdd_debugfs_process_iface_stats(hdd_adapter_t *adapter,
 			"\n\n===LL_STATS_IFACE: num_peers: %d===", num_peers);
 
 	if (false == hdd_get_interface_info(adapter, &iface_stat->info)) {
+		mutex_unlock(&llstats_mutex);
 		hdd_err("hdd_get_interface_info get fail");
 		return;
 	}
@@ -136,6 +147,7 @@ void hdd_debugfs_process_iface_stats(hdd_adapter_t *adapter,
 	}
 
 	ll_stats.len += len;
+	mutex_unlock(&llstats_mutex);
 	EXIT();
 }
 
@@ -150,7 +162,9 @@ void hdd_debugfs_process_peer_stats(hdd_adapter_t *adapter, void *data)
 
 	ENTER();
 
+	mutex_lock(&llstats_mutex);
 	if (!ll_stats.result) {
+		mutex_unlock(&llstats_mutex);
 		hdd_err("LL statistics buffer is NULL");
 		return;
 	}
@@ -197,6 +211,7 @@ void hdd_debugfs_process_peer_stats(hdd_adapter_t *adapter, void *data)
 				(num_rate * sizeof(tSirWifiRateStat)));
 	}
 	ll_stats.len += len;
+	mutex_unlock(&llstats_mutex);
 	EXIT();
 
 }
@@ -212,7 +227,9 @@ void hdd_debugfs_process_radio_stats(hdd_adapter_t *adapter,
 
 	ENTER();
 
+	mutex_lock(&llstats_mutex);
 	if (!ll_stats.result) {
+		mutex_unlock(&llstats_mutex);
 		hdd_err("LL statistics buffer is NULL");
 		return;
 	}
@@ -274,26 +291,35 @@ void hdd_debugfs_process_radio_stats(hdd_adapter_t *adapter,
 		radio_stat++;
 	}
 	ll_stats.len += len;
+	mutex_unlock(&llstats_mutex);
 	EXIT();
 }
 
 static inline void wlan_hdd_llstats_free_buf(void)
 {
+	mutex_lock(&llstats_mutex);
 	qdf_mem_free(ll_stats.result);
 	ll_stats.result = NULL;
 	ll_stats.len =  0;
+	mutex_unlock(&llstats_mutex);
 }
 
 static int wlan_hdd_llstats_alloc_buf(void)
 {
+	mutex_lock(&llstats_mutex);
+	if (ll_stats.result) {
+		mutex_unlock(&llstats_mutex);
+		hdd_err("Buffer is already allocated");
+		return 0;
+	}
 	ll_stats.len = 0;
-
 	ll_stats.result = qdf_mem_malloc(DEBUGFS_LLSTATS_BUF_SIZE);
 	if (!ll_stats.result) {
+		mutex_unlock(&llstats_mutex);
 		hdd_err("LL Stats buffer allocation failed");
 		return -EINVAL;
 	}
-
+	mutex_unlock(&llstats_mutex);
 	return 0;
 }
 
@@ -314,15 +340,17 @@ static ssize_t hdd_debugfs_stats_update(char __user *buf, size_t count,
 	ssize_t ret_cnt;
 
 	ENTER();
-
+	mutex_lock(&llstats_mutex);
 	if (!ll_stats.result) {
+		mutex_unlock(&llstats_mutex);
 		hdd_err("Trying to read from NULL buffer");
 		return 0;
 	}
 
-	hdd_info("LL stats read req: count: %zu, pos: %lld", count, *pos);
 	ret_cnt = simple_read_from_buffer(buf, count, pos,
 			ll_stats.result, ll_stats.len);
+	mutex_unlock(&llstats_mutex);
+	hdd_debug("LL stats read req: count: %zu, pos: %lld", count, *pos);
 
 	EXIT();
 	return ret_cnt;
