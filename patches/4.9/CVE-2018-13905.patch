From d87585164cef055f8b220f77c58cf7159e176e29 Mon Sep 17 00:00:00 2001
From: Akhil P Oommen <akhilpo@codeaurora.org>
Date: Thu, 8 Mar 2018 20:10:52 +0530
Subject: msm: kgsl: Properly take syncsource_lock spinlock

Syncsource spinlock is not properly taken while removing syncsource
id from the synsource_idr. idr_find() and idr_remove() should be called
atomically. Fix this by keeping idr_find() and idr_remove() inside
a single lock.

Change-Id: I51b8dcd0d67deda746c05e4cbd9eb1355d8f5d0b
Signed-off-by: Akhil P Oommen <akhilpo@codeaurora.org>
---
 drivers/gpu/msm/kgsl.c      | 21 ++-------------------
 drivers/gpu/msm/kgsl_sync.c | 46 +++++++++++++++++++++++++++++++++++----------
 drivers/gpu/msm/kgsl_sync.h |  8 ++++----
 3 files changed, 42 insertions(+), 33 deletions(-)

diff --git a/drivers/gpu/msm/kgsl.c b/drivers/gpu/msm/kgsl.c
index ebf96b53..c62df3d 100644
--- a/drivers/gpu/msm/kgsl.c
+++ b/drivers/gpu/msm/kgsl.c
@@ -966,24 +966,6 @@ static void process_release_memory(struct kgsl_process_private *private)
 	}
 }
 
-static void process_release_sync_sources(struct kgsl_process_private *private)
-{
-	struct kgsl_syncsource *syncsource;
-	int next = 0;
-
-	while (1) {
-		spin_lock(&private->syncsource_lock);
-		syncsource = idr_get_next(&private->syncsource_idr, &next);
-		spin_unlock(&private->syncsource_lock);
-
-		if (syncsource == NULL)
-			break;
-
-		kgsl_syncsource_cleanup(private, syncsource);
-		next = next + 1;
-	}
-}
-
 static void kgsl_process_private_close(struct kgsl_device_private *dev_priv,
 		struct kgsl_process_private *private)
 {
@@ -1002,7 +984,8 @@ static void kgsl_process_private_close(struct kgsl_device_private *dev_priv,
 
 	kgsl_process_uninit_sysfs(private);
 
-	process_release_sync_sources(private);
+	/* Release all syncsource objects from process private */
+	kgsl_syncsource_process_release_syncsources(private);
 
 	/* When using global pagetables, do not detach global pagetable */
 	if (private->pagetable->name != KGSL_MMU_GLOBAL_PT)
diff --git a/drivers/gpu/msm/kgsl_sync.c b/drivers/gpu/msm/kgsl_sync.c
index a4de6a0..d484894 100644
--- a/drivers/gpu/msm/kgsl_sync.c
+++ b/drivers/gpu/msm/kgsl_sync.c
@@ -623,18 +623,11 @@ void kgsl_syncsource_put(struct kgsl_syncsource *syncsource)
 		kref_put(&syncsource->refcount, kgsl_syncsource_destroy);
 }
 
-void kgsl_syncsource_cleanup(struct kgsl_process_private *private,
+static void kgsl_syncsource_cleanup(struct kgsl_process_private *private,
 				struct kgsl_syncsource *syncsource)
 {
 	struct kgsl_syncsource_fence *sfence, *next;
 
-	spin_lock(&private->syncsource_lock);
-	if (syncsource->id != 0) {
-		idr_remove(&private->syncsource_idr, syncsource->id);
-		syncsource->id = 0;
-	}
-	spin_unlock(&private->syncsource_lock);
-
 	/* Signal all fences to release any callbacks */
 	spin_lock(&syncsource->lock);
 
@@ -659,10 +652,17 @@ long kgsl_ioctl_syncsource_destroy(struct kgsl_device_private *dev_priv,
 
 	spin_lock(&private->syncsource_lock);
 	syncsource = idr_find(&private->syncsource_idr, param->id);
-	spin_unlock(&private->syncsource_lock);
 
-	if (syncsource == NULL)
+	if (syncsource == NULL) {
+		spin_unlock(&private->syncsource_lock);
 		return -EINVAL;
+	}
+
+	if (syncsource->id != 0) {
+		idr_remove(&private->syncsource_idr, syncsource->id);
+		syncsource->id = 0;
+	}
+	spin_unlock(&private->syncsource_lock);
 
 	kgsl_syncsource_cleanup(private, syncsource);
 	return 0;
@@ -807,6 +807,32 @@ static void kgsl_syncsource_fence_release(struct fence *fence)
 	kfree(sfence);
 }
 
+void kgsl_syncsource_process_release_syncsources(
+		struct kgsl_process_private *private)
+{
+	struct kgsl_syncsource *syncsource;
+	int next = 0;
+
+	while (1) {
+		spin_lock(&private->syncsource_lock);
+		syncsource = idr_get_next(&private->syncsource_idr, &next);
+
+		if (syncsource == NULL) {
+			spin_unlock(&private->syncsource_lock);
+			break;
+		}
+
+		if (syncsource->id != 0) {
+			idr_remove(&private->syncsource_idr, syncsource->id);
+			syncsource->id = 0;
+		}
+		spin_unlock(&private->syncsource_lock);
+
+		kgsl_syncsource_cleanup(private, syncsource);
+		next = next + 1;
+	}
+}
+
 static const char *kgsl_syncsource_get_timeline_name(struct fence *fence)
 {
 	struct kgsl_syncsource_fence *sfence =
diff --git a/drivers/gpu/msm/kgsl_sync.h b/drivers/gpu/msm/kgsl_sync.h
index 7c9f334e..64c248c 100644
--- a/drivers/gpu/msm/kgsl_sync.h
+++ b/drivers/gpu/msm/kgsl_sync.h
@@ -108,8 +108,8 @@ long kgsl_ioctl_syncsource_signal_fence(struct kgsl_device_private *dev_priv,
 
 void kgsl_syncsource_put(struct kgsl_syncsource *syncsource);
 
-void kgsl_syncsource_cleanup(struct kgsl_process_private *private,
-					struct kgsl_syncsource *syncsource);
+void kgsl_syncsource_process_release_syncsources(
+		struct kgsl_process_private *private);
 
 void kgsl_dump_fence(struct kgsl_drawobj_sync_event *event,
 					char *fence_str, int len);
@@ -182,8 +182,8 @@ static inline void kgsl_syncsource_put(struct kgsl_syncsource *syncsource)
 
 }
 
-static inline void kgsl_syncsource_cleanup(struct kgsl_process_private *private,
-					struct kgsl_syncsource *syncsource)
+static inline void kgsl_syncsource_process_release_syncsources(
+		struct kgsl_process_private *private)
 {
 
 }
-- 
cgit v1.1

