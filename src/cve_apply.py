#!/usr/bin/env python3

import collections
import getopt
import os
import subprocess
import sys

from utils import ioutils


"""
Reads the Linux version from the kernel Makefile.

Args:
    kernel_repo The path to the kernel repository

Returns
    Linux version string (e.g. "3.10.9").
"""


def parse_linux_version(kernel_repo):

    kernel_version = ""
    makefile_name = "Makefile"

    version_components = ["VERSION", "PATCHLEVEL", "SUBLEVEL", "EXTRAVERSION"]

    with open(kernel_repo + '/' + makefile_name) as mk:
        for line in mk:
            for component in version_components:
                if component in line:
                    number = ""
                    try:
                        number = line.split('=')[1].strip()
                    except IndexError:
                        pass
                    kernel_version += (number + '.')

                # check if we read everything
                if kernel_version.count('.') == len(version_components):
                    # remove trailing version delimiters ('.')
                    while kernel_version.endswith('.'):
                        kernel_version = kernel_version[:-1]
                    return kernel_version


"""
Print usage information about this program.
"""


def print_usage():

    print("usage: cve_apply.py <OPTIONS> kernel_repo\n")
    print("<OPTIONS>")
    print("\t -h          Print this text\n" +
          "\t -i          Path to the file containing the CVE patch names\n" +
          "\t -b          Base directory path containing the CVE patches\n")


"""
Print current execution progress to the console.

Args:
    current: The current element index.
    total:   The total number of elements to process.

Returns:
    Nothing
"""

def print_progress(current, total):

    print("[I] Progress: " + str(int(current / total * 100)) + "% ("
          + str(current) + "/" + str(total) + ")", end='\r')


"""
Apply a set of CVE patches to a given git repository.

Args:
    path:    The path to the git repository.
    patches: A list of absolute paths to the git patchfiles.

Returns:
    A key value map containing the following information:
        k -> CVE ID
        v -> Commit SHA
"""


def apply_cve_patches(path, patches):

    # keep track of applied patches and their SHAs, as we need this to push
    # to gerrit later (with an appropriate topic on the change)
    applied_patches = {}

    progress = 0
    patch_count = len(patches)
    for patch in patches:
        cve_name = os.path.splitext(os.path.basename(patch))[0]
        print("[I] Applying " + cve_name)
        print_progress(progress, patch_count)
        progress += 1
        if progress == patch_count:
            print_progress(progress, patch_count)
            print()

        # command to apply the patche
        cmd = ["git", "-C", path, "am", "--3way", patch]
        rc = subprocess.call(cmd, stdout=subprocess.DEVNULL)
        if rc == 0:
            # make sure the commit message hook is applied (for Gerrit Change-ID)
            cmd = ["git", "-C", path, "commit", "--amend", "-C", "HEAD"]
            rc = subprocess.call(cmd, stdout=subprocess.DEVNULL)
            # save CVE ID - SHA link for later use
            cmd = ["git", "-C", path, "log", "-1", "--pretty=format:%H"]
            commit_hash = subprocess.check_output(cmd)
            applied_patches[cve_name] = commit_hash.decode("utf-8")
        else:
            # whatever went wrong, undo it!
            cmd = ["git", "-C", path, "reset", "--hard", "HEAD"]
            rc = subprocess.call(cmd, stdout=subprocess.DEVNULL)
            cmd = ["git", "-C", path, "am", "--skip"]
            rc = subprocess.call(cmd, stdout=subprocess.DEVNULL)
            print("[E] Failed to apply: " + patch)

    return applied_patches


"""
Save information about the patches we applied to a file.

Args:
    path:    The path to the output file.
    patches: A key value map containing the following information:
                k -> CVE ID
                v -> Commit SHA

Returns:
    Nothing
"""


def write_patch_status(path, patches):

    if ioutils.file_exists(path):
        fp = open(path, "r")
        # add existing information to our map
        file_lines = fp.read().strip().split('\n')
        fp.close()
        for line in file_lines:
            elems = line.split('\t')
            key = elems[0]
            value = ""
            if len(elems) >= 2:
                value = elems[1]
            patches[key] = value

    # construct an ordered dict for writing
    od = collections.OrderedDict(sorted(patches.items()))

    # write the complete kvmap
    with open(path, "w") as fp:
        for k, v in od.items():
            fp.write(k + "\t" + v + "\n")


"""
Save information about the patches we should push to Gerrit to a file.

Args:
    path:    The path to the output file.
    patches: A key value map containing the following information:
                k -> CVE ID
                v -> Commit SHA

Returns:
    Nothing
"""


def write_push_file(path, patches):

    # construct an ordered dict for writing
    od = collections.OrderedDict(sorted(patches.items()))

    # write the complete kvmap
    with open(path, "w") as fp:
        for k, v in od.items():
            fp.write(k + "\t" + v + "\n")


"""
Entrypoint for callers

Args:
    kernel_repo: The path to the kernel git repository to patch.
    input_file:  The path to the file telling us which CVE patches to apply.
    base_dir:    The path to the directory containing the CVE git patches.

Returns:
    Nothing
"""


def run(kernel_repo, input_file, base_dir):
    # read the kernel version
    linux_version = parse_linux_version(kernel_repo)
    # we only want VERSION + PATCHLEVEL
    while linux_version.count('.') > 1:
        linux_version = linux_version[:linux_version.rfind('.')]

    # load the version specific patches
    version_specifc_patches_dir = os.path.abspath(os.path.join(base_dir, linux_version))

    # figure out which patches we should apply
    patches = []
    with open(input_file, "r") as fp:
        contents = fp.read().strip().split('\n')
        for patch in contents:
            patches.append(os.path.join(version_specifc_patches_dir, patch))

    # keep track of applied patches and their SHAs, as we need this to push
    # to gerrit later (with an appropriate topic on the change)
    applied_patches_file = os.path.join(kernel_repo, "CVE")
    applied_patches_push_file = os.path.join(kernel_repo, "CVE_PUSH")
    if not ioutils.is_accessible(applied_patches_file, "w+"):
        print("[E] Failed to open file for writing: "
              + os.path.abspath(applied_patches_file))
        sys.exit(2)

    # apply the patches
    applied_patches = apply_cve_patches(kernel_repo, patches)
    write_push_file(applied_patches_push_file, applied_patches)
    write_patch_status(applied_patches_file, applied_patches)


"""
Entrypoint to the Python CVE patcher.
"""


def main():

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hi:b:",
                                   ["help", "input=", "basedir="])
    except getopt.GetoptError as err:
        # print help information and exit
        print(str(err))
        print_usage()
        sys.exit(2)

    # check for required args
    if len(sys.argv) < 2:
        print("[E] Invalid number of args (required: 2, found: "
              + str(len(sys.argv)) + ")!")
        print_usage()
        sys.exit(2)

    # file containing the CVE patch file names
    input_file = None
    # directory containing the CVE patches
    base_dir = None
    # directory containing the kernel repo to be patched
    kernel_repo = sys.argv[-1]

    for o, a in opts:
        if o in ("-h", "--help"):
            print_usage()
            sys.exit()
        elif o in ("-i", "--input"):
            input_file = a
        elif o in ("-b", "--basedir"):
            base_dir = a
        else:
            print("[E] unhandled option: " + o)
            sys.exit(2)

    if not input_file or not ioutils.file_exists(input_file):
        print("[E] invalid CVE input file: " + str(input_file))
        return

    if not base_dir or not ioutils.dir_exists(base_dir):
        print("[E] invalid patch base directory: " + str(base_dir))
        return

    if not kernel_repo or not ioutils.dir_exists(kernel_repo):
        print("[E] invalid kernel directory: " + kernel_repo)
        return

    if ".git" not in os.listdir(kernel_repo):
        print("[E] kernel directory does not seem to be a git repository")
        return

    run(kernel_repo, input_file, base_dir)


if __name__ == "__main__":
    main()
