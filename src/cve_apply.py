#!/usr/bin/env python3

import collections
import getopt
import os
import subprocess
import sys
import time

from cve import CveWrapper
from utils import ioutils


"""
Reads the Linux version from the kernel Makefile.

Args:
    kernel_repo The path to the kernel repository

Returns
    Linux version string (e.g. "3.10.9").
"""


def parse_linux_version(kernel_repo):

    kernel_version = ""
    makefile_name = "Makefile"

    version_components = ["VERSION", "PATCHLEVEL", "SUBLEVEL", "EXTRAVERSION"]

    with open(kernel_repo + '/' + makefile_name) as mk:
        for line in mk:
            for component in version_components:
                if component in line:
                    number = ""
                    try:
                        number = line.split('=')[1].strip()
                    except IndexError:
                        pass
                    kernel_version += (number + '.')

                # check if we read everything
                if kernel_version.count('.') == len(version_components):
                    # remove trailing version delimiters ('.')
                    while kernel_version.endswith('.'):
                        kernel_version = kernel_version[:-1]
                    return kernel_version


"""
Builds a list of CVE objects under the given path.

Args:
    path:      The path containing the patchfiles.

Returns:
    A dict containing CveWrapper objects that have a name and git patchfiles.
"""


def load_local_cves(path):

    cves = {}
    patch_prefix = "CVE-"

    for k_version in os.listdir(path):
        for node in os.listdir(os.path.join(path, k_version)):
            if node.startswith(patch_prefix):
                cve_name = node[:node.rfind('.')]
                multipart_index = cve_name.rfind('_')
                if multipart_index != -1:
                    cve_name = cve_name[:cve_name.rfind('_')]
                if cve_name in cves:
                    # we already have this CVE
                    continue

                cve_object = CveWrapper.CveWrapper(cve_name, path)
                cves[cve_name] = cve_object

    return cves


"""
Print usage information about this program.
"""


def print_usage():

    print("usage: cve_apply.py <OPTIONS> kernel_repo\n")
    print("<OPTIONS>")
    print("\t -h          Print this text\n" +
          "\t -i          Path to the file containing the CVE patch names\n" +
          "\t -b          Base directory path containing the CVE patches\n")


"""
Print current execution progress to the console.

Args:
    current: The current element index.
    total:   The total number of elements to process.

Returns:
    Nothing
"""

def print_progress(current, total, end='\r'):

    print("[I] Progress: " + str(int(current / total * 100)) + "% ("
          + str(current) + "/" + str(total) + ")", end=end)


"""
Apply a set of CVE patches to a given git repository.

Args:
    path:     The path to the git repository.
    patches:  A list of absolute paths to the git patchfiles.

Returns:
    A key value map containing the following information:
        k -> CVE ID
        v -> Commit SHA
"""


def apply_cve_patches(path, patches):

    # keep track of applied patches and their SHAs, as we need this to push
    # to gerrit later (with an appropriate topic on the change)
    applied_patches = {}

    progress = 0
    patch_count = len(patches)
    for patch in patches:
        cve_name = os.path.splitext(os.path.basename(patch))[0]
        print("[I] Applying " + cve_name)

        # check if the patch can be applied
        cmd = ["git", "-C", path, "apply", "--check", patch]
        rc = subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

        # print progress to stdout
        progress += 1
        print_progress(progress, patch_count, end='\n')

        if rc == 0:
            sys.exit()
            # actually apply the patch
            cmd = ["git", "-C", path, "am", patch]
            rc = subprocess.call(cmd, stdout=subprocess.DEVNULL)
            # make sure the commit message hook is applied (for Gerrit Change-ID)
            cmd = ["git", "-C", path, "commit", "--amend", "-C", "HEAD"]
            rc = subprocess.call(cmd, stdout=subprocess.DEVNULL)
            # save CVE ID - SHA link for later use
            cmd = ["git", "-C", path, "log", "-1", "--pretty=format:%H"]
            commit_hash = subprocess.check_output(cmd)
            applied_patches[cve_name] = commit_hash.decode("utf-8")
        else:
            print("[E] " + patch + " does not apply!")
            # let the user resolve the conflicts or skip the patch
            answer = ""
            while answer != "m" and answer != "s":
                answer = input("options: (m)anual conflict resolution\n" +
                               "         (s)kip the patch\n" +
                               "answer: ")

            if answer == "m":
                # apply the patch and open a git shell
                cmd = ["git", "-C", path, "am", "--3way", patch]
                rc = subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                wait_file = os.path.join(path, ".git/rebase-apply")
                print("[I] Waiting for " + wait_file + " to go away..")
                while os.path.exists(wait_file):
                    time.sleep(1)
            elif answer == "s":
                continue

    return applied_patches


"""
Save information about the patches we applied to a file.

Args:
    path:    The path to the output file.
    patches: A key value map containing the following information:
                k -> CVE ID
                v -> Commit SHA

Returns:
    Nothing
"""


def write_patch_status(path, patches):

    if ioutils.file_exists(path):
        fp = open(path, "r")
        # add existing information to our map
        file_lines = fp.read().strip().split('\n')
        fp.close()
        for line in file_lines:
            elems = line.split('\t')
            key = elems[0]
            value = ""
            if len(elems) >= 2:
                value = elems[1]
            patches[key] = value

    # construct an ordered dict for writing
    od = collections.OrderedDict(sorted(patches.items()))

    # write the complete kvmap
    with open(path, "w") as fp:
        for k, v in od.items():
            fp.write(k + "\t" + v + "\n")


"""
Save information about the patches we should push to Gerrit to a file.

Args:
    path:    The path to the output file.
    patches: A key value map containing the following information:
                k -> CVE ID
                v -> Commit SHA

Returns:
    Nothing
"""


def write_push_file(path, patches):

    # construct an ordered dict for writing
    od = collections.OrderedDict(sorted(patches.items()))

    # write the complete kvmap
    with open(path, "w") as fp:
        for k, v in od.items():
            fp.write(k + "\t" + v + "\n")


"""
Entrypoint for callers

Args:
    kernel_repo: The path to the kernel git repository to patch.
    input_file:  The path to the file telling us which CVE patches to apply.
    cves:        A dict of CveWrapper objects

Returns:
    Nothing
"""


def run(kernel_repo, input_file, cves):
    # read the kernel version
    linux_version = parse_linux_version(kernel_repo)
    # we only want VERSION + PATCHLEVEL
    while linux_version.count('.') > 1:
        linux_version = linux_version[:linux_version.rfind('.')]

    # figure out which patches we should apply
    patches = []
    with open(input_file, "r") as fp:
        contents = fp.read().strip().split('\n')
        for cve_name in contents:
            if not cves[cve_name].patchfiles[linux_version]:
                print("[W] No local patchfile for: " + cve_name + " for kernel: " + linux_version)
                continue
            for patch_part in cves[cve_name].patchfiles[linux_version]:
                patches.append(patch_part)

    # keep track of applied patches and their SHAs, as we need this to push
    # to gerrit later (with an appropriate topic on the change)
    applied_patches_file = os.path.join(kernel_repo, "CVE")
    applied_patches_push_file = os.path.join(kernel_repo, "CVE_PUSH")
    if not ioutils.is_accessible(applied_patches_file, "w+"):
        print("[E] Failed to open file for writing: "
              + os.path.abspath(applied_patches_file))
        sys.exit(2)

    # apply the patches
    applied_patches = apply_cve_patches(kernel_repo, patches)
    write_push_file(applied_patches_push_file, applied_patches)
    write_patch_status(applied_patches_file, applied_patches)


"""
Entrypoint to the Python CVE patcher.
"""


def main():

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hi:b:",
                                   ["help", "input=", "basedir="])
    except getopt.GetoptError as err:
        # print help information and exit
        print(str(err))
        print_usage()
        sys.exit(2)

    # check for required args
    if len(sys.argv) < 2:
        print("[E] Invalid number of args (required: 2, found: "
              + str(len(sys.argv)) + ")!")
        print_usage()
        sys.exit(2)

    # file containing the CVE patch file names
    input_file = None
    # directory containing the CVE patches
    base_dir = None
    # directory containing the kernel repo to be patched
    kernel_repo = sys.argv[-1]

    for o, a in opts:
        if o in ("-h", "--help"):
            print_usage()
            sys.exit()
        elif o in ("-i", "--input"):
            input_file = a
        elif o in ("-b", "--basedir"):
            base_dir = a
        else:
            print("[E] unhandled option: " + o)
            sys.exit(2)

    if not input_file or not ioutils.file_exists(input_file):
        print("[E] invalid CVE input file: " + str(input_file))
        return

    if not base_dir or not ioutils.dir_exists(base_dir):
        print("[E] invalid patch base directory: " + str(base_dir))
        return

    if not kernel_repo or not ioutils.dir_exists(kernel_repo):
        print("[E] invalid kernel directory: " + kernel_repo)
        return

    if ".git" not in os.listdir(kernel_repo):
        print("[E] kernel directory does not seem to be a git repository")
        return

    local_cves = load_local_cves(base_dir)
    run(kernel_repo, input_file, local_cves)


if __name__ == "__main__":
    main()
