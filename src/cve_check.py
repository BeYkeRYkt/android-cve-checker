#!/usr/bin/env python3

import collections
import getopt
import os
import subprocess
import sys

from cve import CveWrapper
from stats_engine import collect_stats
from utils import ioutils


"""
Builds a list of CVE objects under the given path.

Args:
    path:      The path containing the patchfiles.
    k_version: The Linux kernel version.

Returns:
    A list with absolute paths to the patchfiles.
"""


def load_cves(path, k_version):

    cves = []
    patch_prefix = "CVE-"

    for node in os.listdir(os.path.join(path, k_version)):
        if node.startswith(patch_prefix):
            cve_name = node[:node.rfind('.')]
            multipart_index = cve_name.rfind('_')
            if multipart_index != -1:
                cve_name = cve_name[:cve_name.rfind('_')]
            cve_object = CveWrapper.CveWrapper(cve_name, path)
            cves.append(cve_object)

    return cves


"""
Reads the Linux version from the kernel Makefile.

Args:
    kernel_repo The path to the kernel repository

Returns
    Linux version string (e.g. "3.10.9").
"""


def parse_linux_version(kernel_repo):

    kernel_version = ""
    makefile_name = "Makefile"

    version_components = ["VERSION", "PATCHLEVEL", "SUBLEVEL", "EXTRAVERSION"]

    with open(kernel_repo + '/' + makefile_name) as mk:
        for line in mk:
            for component in version_components:
                if component in line:
                    number = ""
                    try:
                        number = line.split('=')[1].strip()
                    except IndexError:
                        pass
                    kernel_version += (number + '.')

                # check if we read everything
                if kernel_version.count('.') == len(version_components):
                    # remove trailing version delimiters ('.')
                    while kernel_version.endswith('.'):
                        kernel_version = kernel_version[:-1]
                    return kernel_version


"""
Check if a git patch applies either cleanly or in reverse.

Args:
    kernel_repo: The kernel git repository.
    cve_patch:   The CVE git patch to check.

Returns:
    0 - patch applies cleanly
    1 - patch applies in reverse (already applied?)
    2 - patch does not apply
"""


def basic_check(kernel_repo, cve_patch):

    # try to apply the patch normally
    cmd = ["git", "-C", kernel_repo, "apply", "--check", cve_patch]
    ret = subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    # patch applies normally
    if ret == 0:
        return 0

    # try to apply the patch in reverse
    cmd = ["git", "-C", kernel_repo, "apply", "--check", "--reverse",
           cve_patch]
    ret = subprocess.call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    # patch applies in reverse
    if ret == 0:
        return 1

    # we ran out of options, probably need an advanced check..
    return 2


"""
Print usage information about this program.
"""


def print_usage():

    print("usage: pycve.py <OPTIONS> kernel_repo\n")
    print("<OPTIONS>")
    print("\t -h          Print this text\n" +
          "\t -i          Path to the directory containing the CVE patches\n" +
          "\t -o          Output file destination\n")


"""
Print current execution progress to the console.

Args:
    current: The current element index.
    total:   The total number of elements to process.

Returns:
    Nothing
"""

def print_progress(current, total):

    print("[I] Progress: " + str(int(current / total * 100)) + "% ("
          + str(current) + "/" + str(total) + ")", end='\r')


"""
Check whether or not a patch applies to a git repository.

Args:
    path:  The path to the git repository.
    patch: The absolute path to the git patchfiles.

Returns:
    A tuple containing information about the patch status:
    The first field holds a concise status:
        [0] -> applies cleanly
        [1] -> already applied
        [2] -> does not apply
    The second field (only valid if status == 2) is a tuple again and holds information from git
    about the patch, how many lines are already applied and how many are missing.
"""


def check_patch(path, patch):

    status = basic_check(path, patch)

    # collect stats for patch
    (added, removed) = collect_stats(path, patch)

    return (status, (added, removed))


"""
Save information about the patches we applied to a file.

Args:
    path:    The path to the output file.
    patches: A key value map containing the following information:
                k -> CVE ID
                v -> Commit SHA

Returns:
    Nothing
"""


def write_patch_status(path, patches):

    if ioutils.file_exists(path):
        fp = open(path, "r")
        # add existing information to our map
        file_lines = fp.read().strip().split('\n')
        fp.close()
        for line in file_lines:
            elems = line.split('\t')
            key = elems[0]
            value = ""
            if len(elems) >= 2:
                value = elems[1]
            patches[key] = value

    # construct an ordered dict for writing
    od = collections.OrderedDict(sorted(patches.items()))

    # write the complete kvmap
    with open(path, "w") as fp:
        for k, v in od.items():
            fp.write(k + "\t" + v + "\n")


"""
Entrypoint for callers

Args:
    kernel_repo: The path to the kernel git repository to patch.
    patches_dir: The path to the directory containing the CVE git patches.
    output_dir:  The path to store the follwing output files:
                    CVE_applied   -> CVEs that are already applied
                    CVE_clean     -> CVEs that apply cleanly
                    CVE_conflicts -> CVEs that do not apply

Returns:
    Nothing
"""


def run(kernel_repo, patches_dir, output_dir):

    # patches that apply cleanly
    clean = []
    # patches that are already applied
    reverse = []
    # patches that do not apply
    conflicting = []

    # file containing the already applied CVEs
    applied_file = os.path.join(output_dir, "CVE_applied")
    # file containing the conflicting CVEs
    conflicting_file = os.path.join(output_dir, "CVE_conflicts")
    # file containing the clean CVEs
    clean_file = os.path.join(output_dir, "CVE_clean")

    # read the kernel version
    linux_version = parse_linux_version(kernel_repo)
    # we only want VERSION + PATCHLEVEL
    while linux_version.count('.') > 1:
        linux_version = linux_version[:linux_version.rfind('.')]

    # load the CVE objects
    cves = load_cves(patches_dir, linux_version)
    cves = sorted(cves)

    # open files
    clean_file_fp = open(clean_file, "w")
    reverse_file_fp = open(applied_file, "w")
    conflicting_file_fp = open(conflicting_file, "w")

    # perform the actual checking and write to output files
    progress = 0
    cve_count = len(cves)
    for cve in cves:
        if not cve.patchfiles[linux_version]:
            # no patchfiles, this kernel version may not be affected?
            continue

        print("[I] Checking " + cve.name)

        cve_status = []
        for patchfile in cve.patchfiles[linux_version]:
            print("[I] Patchfile: " + patchfile)
            (status, diff_info) = check_patch(kernel_repo, patchfile)
            cve_status.append(status)
            (added, removed) = diff_info
            # print diff stats
            stats_string = "\tstats: "
            if added is not None:
                (actual_plus, total_plus) = added
                stats_string += (str(actual_plus) + '/' + str(total_plus)
                                 + " insertions(+)")
            if removed is not None:
                # print a separator if needed
                if added is not None:
                    stats_string += ", "
                (actual_minus, total_minus) = removed
                stats_string += (str(actual_minus) + '/' + str(total_minus)
                                 + " deletions(-)")
            print(stats_string)

        # handle multipart patches
        patch_status = 0
        for part_status in cve_status:
            patch_status += part_status

        if patch_status == 0:
            clean.append(cve.name)
        elif patch_status == 1:
            reverse.append(cve.name)
        elif patch_status == 2:
            conflicting.append(cve.name)

    # write patch status to files
    for cve_name in clean:
        clean_file_fp.write(cve_name + "\n")
    for cve_name in reverse:
        reverse_file_fp.write(cve_name + "\n")
    for cve_name in conflicting:
        conflicting_file_fp.write(cve_name + "\n")

    # close file pointers
    clean_file_fp.close()
    reverse_file_fp.close()
    conflicting_file_fp.close()

    # update the CVE status file in kernel if present
    applied_patches = {}
    for patch in reverse:
        if patch.endswith(".patch"):
            patch = os.path.splitext(patch)[0]
        applied_patches[patch] = ""

    applied_patches_file = os.path.join(kernel_repo, "CVE")
    if ioutils.is_accessible(applied_patches_file, "r+"):
        write_patch_status(applied_patches_file, applied_patches)

    print_progress(progress, cve_count)
    progress += 1
    if progress == cve_count:
        print_progress(progress, cve_count)
        print()


"""
Entrypoint to the Python CVE checker.
"""


def main():

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hi:o:",
                                   ["help", "input=", "output="])
    except getopt.GetoptError as err:
        # print help information and exit
        print(str(err))
        print_usage()
        sys.exit(2)

    # check for required args
    if len(sys.argv) < 2:
        print("[E] Invalid number of args (required: 2, found: "
              + str(len(sys.argv)) + ")!")
        print_usage()
        sys.exit(2)

    # directory containing the CVE patches
    input_dir = None
    # directory containing the kernel repo to be patched
    kernel_repo = sys.argv[-1]
    # the place to store the results
    output_dir = None

    for o, a in opts:
        if o in ("-h", "--help"):
            print_usage()
            sys.exit()
        elif o in ("-i", "--input"):
            input_dir = a
        elif o in ("-o", "--output"):
            output_dir = a
        else:
            print("[E] unhandled option: " + o)
            sys.exit(2)

    # check for required directories
    if output_dir:
        ioutils.check_create(output_dir)

    if not input_dir or not ioutils.dir_exists(input_dir):
        print("[E] invalid CVE input directory: " + str(input_dir))
        return

    if not output_dir:
        print("[E] invalid output directory: " + str(output_dir))
        return

    if not kernel_repo or not ioutils.dir_exists(kernel_repo):
        print("[E] invalid kernel directory: " + kernel_repo)
        return

    if ".git" not in os.listdir(kernel_repo):
        print("[E] kernel directory does not seem to be a git repository")
        return

    run(kernel_repo, input_dir, output_dir)


if __name__ == "__main__":
    main()
