#!/usr/bin/env python3

import getopt
import os
import urllib.request
import sys

# to query CVE list from Lineage tracker
import json
try:
    import requests
except ImportError:
    print("[E] 'requests' module not installed")
    print("[E] run 'pip[3] install requests' to get it")
    sys.exit()

from cve import CveWrapper

def prepare_link(link):
    if ("codeaurora" in link) or ("git.kernel.org" in link): 
        link = link.replace("commit","patch")
    elif "github.com" in link:
        link+=".patch"
    elif "android.googlesource.com" in  link:
        # google have a mirror on github
        link = link[-40:]
        link = "https://github.com/aosp-mirror/kernel_msm/commit/" + link + ".patch"
    elif "patchwork" in link:
        link = link + "mbox/"
    #print("Replaced " + link)
    return link


def load_tracker_cves():

    cves = {}
    URL = "http://cve.lineageos.org/api/v1/cves"

    response = requests.get(URL)
    data = response.json()

    for entry in data.keys():
        curr_cve_obj = data[entry]
        name = curr_cve_obj["cve_name"]
        links = curr_cve_obj["links"]
        cve_object = CveWrapper.CveWrapper(name)
        for curr_link in links:
            if "desc" in curr_link:
                version = curr_link["desc"]
                patch_link = curr_link["link"]

                # skip all vendor stuff
                if "vendor" in patch_link:
                    continue
                
                # skip lineage coz IDK how to parse it
                if "lineageos" in patch_link:
                    continue

                if "cve.mitre.org" in patch_link:
                    continue
    
                if "www.codeaurora.org" in patch_link:
                    continue
                
                if "chromium" in patch_link:
                    continue

                if (version == "3.10") or (version == "3.18") or (version == "4.4"):
                    cve_object.patchfiles[version] = prepare_link(patch_link)
                # handle all patches without desc or with dummy desc
                elif (version.lower() == "patch") or (version == ""):
                    if "msm-3.10" in patch_link:
                        cve_object.patchfiles["3.10"] = prepare_link(patch_link)
                    elif "msm-3.18" in patch_link:
                        cve_object.patchfiles["3.18"] = prepare_link(patch_link)
                    elif "msm-4.4" in patch_link:
                        cve_object.patchfiles["4.4"]  = prepare_link(patch_link)
                    elif "msm-" in patch_link:
                        # skip other versions like 3.4, 4.9, etc
                        continue
                    else:
                        cve_object.patchfiles["3.10"] = prepare_link(patch_link)
                        cve_object.patchfiles["3.18"] = prepare_link(patch_link)
                        cve_object.patchfiles["4.4"]  = prepare_link(patch_link)

        # collect all our CveWrapper instances
        cves[name] = cve_object

    return cves


def load_local_cves(path):

    cves = {}
    patch_prefix = "CVE-"

    for k_version in os.listdir(path):
        for node in os.listdir(os.path.join(path, k_version)):
            if node.startswith(patch_prefix):
                cve_name = node[:node.rfind('.')]
                multipart_index = cve_name.rfind('_')
                if multipart_index != -1:
                    cve_name = cve_name[:cve_name.rfind('_')]
                if cve_name in cves:
                    # we already have this CVE
                    continue

                cve_object = CveWrapper.CveWrapper(cve_name, path)
                cves[cve_name] = cve_object

    return cves


"""
Entrypoint for callers

Args:
    patches_dir:         The path to the directory containing the CVE git patches.
    replace_local_files: Whether or not to replace local patchfiles without asking.

Returns:
    Nothing
"""

def run(patches_dir, replace_local_files=False):

    # load our local CVE patchfiles
    local_cves = load_local_cves(patches_dir)

    # query CVE list from Lineage tracker
    tracker_cves = load_tracker_cves()

    for cve_name in tracker_cves:
        remote_patchfiles = tracker_cves[cve_name].patchfiles
        # iterate patches for each kernel version
        for k_version in remote_patchfiles:
            remote_patchfile = remote_patchfiles[k_version]
            print(remote_patchfile)
            target_path = os.path.join(patches_dir, k_version, cve_name)
            # check if the directory structure exists and create it if not
            if not os.path.exists(os.path.dirname(target_path)):
                os.makedirs(os.path.dirname(target_path))

            target_path += ".patch"
            if os.path.exists(target_path):
                if not replace_local_files:
                    print("[I] " + target_path + " already exists!")
                    answer = ""
                    while answer == "":
                        answer = input("options: (r)emove local file" +
                                       " and sync from server\n" +
                                       "         (s)kip\n" +
                                       "answer: ")
                    if answer == "r":
                        # remove the local file
                        os.remove(target_path)
                    elif answer == "s":
                        continue
                else:
                    # remove the local file
                    os.remove(target_path)

            # download the patch
            print("[I] Downloading " + os.path.basename(target_path))
            try:
                urllib.request.urlretrieve(remote_patchfile, target_path)
                print("    * Saved!")
            except Exception:
                print("    * Failed to download " + remote_patchfile)
            print("")


"""
Print usage information about this program.
"""


def print_usage():

    print("usage: sync_patches.py <OPTIONS> patches_dir")
    print("<OPTIONS>")
    print("\t -h          Print this text\n" +
          "\t -r          Replace local patchfiles without asking\n")


def main():

    # whether or not we should replace local files by default
    replace_local_files = False

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hr", ["help", "replace"])
    except getopt.GetoptError as err:
        # print help information and exit
        print(str(err))
        print_usage()
        sys.exit(2)

    # check for required args
    if len(sys.argv) < 2:
        print("[E] Invalid number of args (required: 2, found: "
              + str(len(sys.argv)) + ")!")
        print_usage()
        sys.exit(2)

    # directory containing the git patchfiles
    patches_dir = sys.argv[-1]

    for o, a in opts:
        if o in ("-h", "--help"):
            print_usage()
            sys.exit()
        elif o in ("-r", "--replace"):
            replace_local_files=True
        else:
            print("[E] unhandled option: " + o)
            sys.exit(2)

    if not patches_dir or not os.path.isdir(patches_dir):
        print("[E] invalid patchfile directory: " + patches_dir)
        return

    run(patches_dir, replace_local_files)


if __name__ == "__main__":
    main()
