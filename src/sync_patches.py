#!/usr/bin/env python3

import getopt
import os
import urllib.request
import sys
import re

# to query CVE list from Lineage tracker
import json
try:
    import requests
except ImportError:
    print("[E] 'requests' module not installed")
    print("[E] run 'pip[3] install requests' to get it")
    sys.exit()

from cve import CveWrapper

def prepare_link(link):
    #print("Before " + link)
    if ("codeaurora" in link) or ("git.kernel.org" in link): 
        link = link.replace("commit","patch")
    elif "github.com" in link:
        link+=".patch"
    elif "android.googlesource.com" in  link:
        # google have a mirror on github
        link = link.replace("%5E%21/#F0","")
        link = link.replace("%5E%21/","")
        link = link.replace("%5E%21","")

        if "kernel/common" in link:
            kernel_type = "kernel_common"
        else:    
            kernel_type = "kernel_msm"

        commit_hash = re.search(r'\/\+\/(\w{40}|\w{12})', link)
        commit_hash = commit_hash.group(0)[3:]
        link = "https://github.com/aosp-mirror/" + kernel_type + "/commit/" + commit_hash + ".patch"
    elif "patchwork" in link:
        link = link + "mbox/"
    #print("Replaced " + link)
    return link

def get_version(desc, link):
    if ("3.4" in link) or ("3.4" in desc):
        return "3.4"
    elif ("3.10" in link) or ("3.10" in desc):
        return "3.10"
    elif ("3.18" in link) or ("3.18" in desc):
        return "3.18"
    elif ("4.4" in link) or ("4.4" in desc):
        return "4.4"
    elif ("4.9" in link) or ("4.9" in desc):
        return "4.9"
    elif ("msm-" in link) or ("2." in desc) or ("3." in desc) or ("4." in desc):
        return "other"
    else:
        return "None"

def skip_link(link):
    # skip all vendor stuff
    if "vendor" in link:
       return True
    
    # skip lineage coz IDK how to parse it
    if "lineageos" in link:
        return True

    if "cve.mitre.org" in link:
        return True

    if "www.codeaurora.org" in link:
        return True
    
    if "chromium" in link:
        return True

    if "bulletin" in link:
        return True

    if "alephsecurity.com" in link:
        return True

    if ("codeaurora.org" in link) and ("/log/?" in link):
        return True
    
    if "tegra" in link:
        return True

    return False

def get_patch_prefix(desc):
    # [1/2] test or test 2/2
    result = re.search(r'(\[)?\d+(\s)?\/(\s)?\d+(\]|\$)?', desc)

    if result == None:
        # 1 of 2
        result = re.search(r'[0-9](\s)?\of(\s)?[0-9](\s|$)?', desc)

        if result == None:
            # part 1 or patch #3
            result = re.search(r'\D{4,5}\b\s(\#)?\d(\s|$|\))', desc)    
        
            if result == None:
                return 0
    
    result = re.search(r'\d+',result.group(0))
    return int(result.group(0))

def load_tracker_cves():

    cves = {}
    URL = "http://cve.lineageos.org/api/v1/cves"

    response = requests.get(URL)
    data = response.json()

    for entry in data.keys():
        curr_cve_obj = data[entry]
        name = curr_cve_obj["cve_name"]
        links = curr_cve_obj["links"]
        for curr_link in links:
            if "desc" in curr_link:
                cve_object = CveWrapper.CveWrapper(name)
                version = curr_link["desc"]
                patch_link = curr_link["link"]

                if (skip_link(patch_link)):
                    continue
                
                kernel_version = get_version(version, patch_link)
    
                if (kernel_version == "other"):
                    continue

                # handle multicommits
                prefix = int(get_patch_prefix(version))
                if prefix != 0:
                    name = curr_cve_obj["cve_name"] + "_" + str(prefix)

                prepared_link = prepare_link(patch_link)
                #print(kernel_version + " " + name + " " + prepared_link)
    
                if (kernel_version == "None"):
                    cve_object.patchfiles["3.4"]  = prepared_link
                    cve_object.patchfiles["3.10"] = prepared_link
                    cve_object.patchfiles["3.18"] = prepared_link
                    cve_object.patchfiles["4.4"]  = prepared_link
                    cve_object.patchfiles["4.9"]  = prepared_link
                else:
                    cve_object.patchfiles[kernel_version] = prepared_link

                # collect all our CveWrapper instances
                cves[name] = cve_object
    sys.exit(0)
    return cves


def load_local_cves(path):

    cves = {}
    patch_prefix = "CVE-"

    for k_version in os.listdir(path):
        for node in os.listdir(os.path.join(path, k_version)):
            if node.startswith(patch_prefix):
                cve_name = node[:node.rfind('.')]
                multipart_index = cve_name.rfind('_')
                if multipart_index != -1:
                    cve_name = cve_name[:cve_name.rfind('_')]
                if cve_name in cves:
                    # we already have this CVE
                    continue

                cve_object = CveWrapper.CveWrapper(cve_name, path)
                cves[cve_name] = cve_object

    return cves


"""
Entrypoint for callers

Args:
    patches_dir:         The path to the directory containing the CVE git patches.
    replace_local_files: Whether or not to replace local patchfiles without asking.

Returns:
    Nothing
"""

def run(patches_dir, replace_local_files=False):

    # load our local CVE patchfiles
    local_cves = load_local_cves(patches_dir)

    # query CVE list from Lineage tracker
    tracker_cves = load_tracker_cves()

    for cve_name in tracker_cves:
        remote_patchfiles = tracker_cves[cve_name].patchfiles
        # iterate patches for each kernel version
        for k_version in remote_patchfiles:
            remote_patchfile = remote_patchfiles[k_version]
            target_path = os.path.join(patches_dir, k_version, cve_name)
            #print("cve_name " + cve_name + " " + remote_patchfile)
            # check if the directory structure exists and create it if not
            if not os.path.exists(os.path.dirname(target_path)):
                os.makedirs(os.path.dirname(target_path))

            target_path += ".patch"
            if os.path.exists(target_path):
                if not replace_local_files:
                    print("[I] " + target_path + " already exists!")
                    continue
                else:
                    # remove the local file
                    os.remove(target_path)

            # download the patch
            print("[I] Downloading " + os.path.basename(target_path) + " from " + remote_patchfile, end = '')
            try:
                urllib.request.urlretrieve(remote_patchfile, target_path)
                print("    * Saved!")
            except Exception:
                print("    * Failed to download " + remote_patchfile)
            print("")


"""
Print usage information about this program.
"""


def print_usage():

    print("usage: sync_patches.py <OPTIONS> patches_dir")
    print("<OPTIONS>")
    print("\t -h          Print this text\n" +
          "\t -r          Replace local patchfiles without asking\n")


def main():

    # whether or not we should replace local files by default
    replace_local_files = False

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hr", ["help", "replace"])
    except getopt.GetoptError as err:
        # print help information and exit
        print(str(err))
        print_usage()
        sys.exit(2)

    # check for required args
    if len(sys.argv) < 2:
        print("[E] Invalid number of args (required: 2, found: "
              + str(len(sys.argv)) + ")!")
        print_usage()
        sys.exit(2)

    # directory containing the git patchfiles
    patches_dir = sys.argv[-1]

    for o, a in opts:
        if o in ("-h", "--help"):
            print_usage()
            sys.exit()
        elif o in ("-r", "--replace"):
            replace_local_files=True
        else:
            print("[E] unhandled option: " + o)
            sys.exit(2)

    if not patches_dir or not os.path.isdir(patches_dir):
        print("[E] invalid patchfile directory: " + patches_dir)
        return

    run(patches_dir, replace_local_files)


if __name__ == "__main__":
    main()
