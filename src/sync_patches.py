#!/usr/bin/env python3

import getopt
import os
import urllib.request
import sys

# to query CVE list from Lineage tracker
import json
try:
    import requests
except ImportError:
    print("[E] 'requests' module not installed")
    print("[E] run 'pip[3] install requests' to get it")
    sys.exit()

from cve import CveWrapper


def load_tracker_cves():

    cves = {}
    URL = "http://cve.lineageos.gr/api/v1/cves"

    response = requests.get(URL)
    data = response.json()["data"]

    for entry in data:
        name = entry["name"]
        patchsets = entry["patchsets"]
        cve_object = CveWrapper.CveWrapper(name)
        for entry in patchsets:
            for version in entry["versions"]:
                cve_object.patchfiles[version] = entry["patches"]

        # collect all our CveWrapper instances
        cves[name] = cve_object

    return cves


def load_local_cves(path):

    cves = {}
    patch_prefix = "CVE-"

    for k_version in os.listdir(path):
        for node in os.listdir(os.path.join(path, k_version)):
            if node.startswith(patch_prefix):
                cve_name = node[:node.rfind('.')]
                multipart_index = cve_name.rfind('_')
                if multipart_index != -1:
                    cve_name = cve_name[:cve_name.rfind('_')]
                if cve_name in cves:
                    # we already have this CVE
                    continue

                cve_object = CveWrapper.CveWrapper(cve_name, path)
                cves[cve_name] = cve_object

    return cves


"""
Entrypoint for callers

Args:
    patches_dir: The path to the directory containing the CVE git patches.

Returns:
    Nothing
"""

def run(patches_dir):

    # load our local CVE patchfiles
    local_cves = load_local_cves(patches_dir)

    # query CVE list from Lineage tracker
    tracker_cves = load_tracker_cves()

    for cve_name in tracker_cves:
        remote_patchfiles = tracker_cves[cve_name].patchfiles
        # iterate patches for each kernel version
        for k_version in remote_patchfiles:
            for i in range(0, len(remote_patchfiles[k_version])):
                remote_patchfile = remote_patchfiles[k_version][i]
                target_path = os.path.join(patches_dir, k_version, cve_name)
                # add multipart suffix
                if i > 0:
                    target_path += "_" + str(i)
                target_path += ".patch"
                if os.path.exists(target_path):
                    if not replace_local_files:
                        print("[I] " + target_path + " already exists!")
                        answer = ""
                        while answer == "":
                            answer = input("options: (r)emove local file" +
                                           " and sync from server\n" +
                                           "         (s)kip\n" +
                                           "answer: ")
                        if answer == "r":
                            # remove the local file
                            os.remove(target_path)
                        elif answer == "s":
                            continue
                    else:
                        # remove the local file
                        os.remove(target_path)

                # download the patch
                print("[I] Downloading " + cve_name + ".patch")
                try:
                    urllib.request.urlretrieve(remote_patchfile, target_path)
                    print("    * Saved!")
                except Exception:
                    print("    * Failed to download " + remote_patchfile)
                print("")


"""
Print usage information about this program.
"""


def print_usage():

    print("usage: sync_patches.py <OPTIONS> patches_dir")


def main():

    # whether or not we should replace local files by default
    replace_local_files = False

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hr", ["help", "replace"])
    except getopt.GetoptError as err:
        # print help information and exit
        print(str(err))
        print_usage()
        sys.exit(2)

    # check for required args
    if len(sys.argv) != 2:
        print("[E] Invalid number of args (required: 2, found: "
              + str(len(sys.argv)) + ")!")
        print_usage()
        sys.exit(2)

    # directory containing the git patchfiles
    patches_dir = sys.argv[-1]

    for o, a in opts:
        if o in ("-h", "--help"):
            print_usage()
            sys.exit()
        elif o in ("-r", "--replace"):
            replace_local_files=True
        else:
            print("[E] unhandled option: " + o)
            sys.exit(2)

    if not patches_dir or not os.path.isdir(patches_dir):
        print("[E] invalid patchfile directory: " + patches_dir)
        return

    run(patches_dir)


if __name__ == "__main__":
    main()
